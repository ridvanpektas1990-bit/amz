name: SaaS ETL (reusable)

on:
  workflow_call:
    inputs:
      period_year:   { type: string, required: false, description: "YYYY (leer = Vormonat)" }
      period_month:  { type: string, required: false, description: "M oder MM (leer = Vormonat)" }
      tenants:       { type: string, required: false, default: "ALL", description: "CSV (Filter) oder ALL" }
      which:         { type: string, required: false, default: "beides", description: "fees|orders|beides" }
      max_parallel:  { type: string, required: false, default: "2" }
    secrets:
      SUPABASE_URL:              { required: true }
      SUPABASE_SERVICE_ROLE_KEY: { required: true }
      LWA_CLIENT_ID:             { required: true }
      LWA_CLIENT_SECRET:         { required: true }

permissions:
  contents: read
  actions: write

jobs:
  prep-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.mk.outputs.matrix }}
      year:   ${{ steps.mk.outputs.year }}
      month:  ${{ steps.mk.outputs.month }}
      count:  ${{ steps.mk.outputs.count }}
    steps:
      - uses: actions/setup-python@v5
        with: { python-version: "3.11" }

      - id: mk
        env:
          IN_PERIOD_YEAR:  ${{ inputs.period_year }}
          IN_PERIOD_MONTH: ${{ inputs.period_month }}
          IN_TENANTS:      ${{ inputs.tenants }}
          SUPABASE_URL:    ${{ secrets.SUPABASE_URL }}
          SUPABASE_KEY:    ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          # Optional: Aktivitätsfenster in Monaten (Default 12; "0" = deaktiviert)
          ACTIVITY_MONTHS: ${{ vars.ACTIVITY_MONTHS }}
          # Optional: harte Einschränkung (z.B. "DE,FR")
          OVERRIDE_CODES:  ${{ vars.OVERRIDE_CODES }}
          # Optional: Grace-Periode in Tagen für neue Connections (Default 45)
          NEW_CONN_GRACE_DAYS: ${{ vars.NEW_CONN_GRACE_DAYS }}
        run: |
          python - << 'PY'
          import os, json, urllib.request
          from datetime import date, timedelta

          def last_month():
              t = date.today()
              first = t.replace(day=1)
              prev = first - timedelta(days=1)
              return prev.year, prev.month

          yy = int(os.getenv("IN_PERIOD_YEAR") or 0) or last_month()[0]
          mm = int(os.getenv("IN_PERIOD_MONTH") or 0) or last_month()[1]

          filt_tenants = [x.strip() for x in (os.getenv("IN_TENANTS") or "ALL").split(",") if x.strip()]
          sb_url = (os.getenv("SUPABASE_URL") or "").rstrip("/")
          sb_key = os.getenv("SUPABASE_KEY") or ""

          def _req(url, headers):
              req = urllib.request.Request(url, headers=headers)
              with urllib.request.urlopen(req, timeout=45) as r:
                  return r.read().decode("utf-8"), r.headers

          # --- Verbindungen laden (inkl. created_at für Grace-Periode)
          url = f"{sb_url}/rest/v1/amazon_connections?select=tenant_id,region,refresh_token,seller_id,marketplaces,created_at"
          rows = []
          try:
              txt, _ = _req(url, {"apikey": sb_key, "Authorization": f"Bearer {sb_key}"})
              rows = json.loads(txt)
          except Exception as e:
              print(f"::error::Failed to load amazon_connections: {e}")

          # Mapping IDs <-> Codes
          MAP_ID2CODE = {
              "A1PA6795UKMFR9":"DE","A13V1IB3VIYZZH":"FR","APJ6JRA9NG5V4":"IT",
              "A1RKKUPIHCS9HS":"ES","A1F83G8C2ARO7P":"GB","A1805IZSGTT6HS":"NL",
              "A2NODRKZP88ZB9":"SE","A1C3SOZRARQ6R3":"PL","AMEN7PMS3EDWL":"BE",
              "A33AVAJ2PDY3EV":"TR","A39IBJ37TRP1C6":"AE","A2Q3Y263D00KWC":"SA",
              "A2VIGQ35RCS4UG":"EG","ATVPDKIKX0DER":"US","A2EUQ1WTGCTBG2":"CA","A1AM78C64UM0Y8":"MX",
              "A1VC38T7YXB528":"JP"
          }
          CODE2ID = {v:k for k,v in MAP_ID2CODE.items()}

          def multi_json_loads(val, max_depth=3):
              """Entschachtelt doppelt/mehrfach serialisierte JSON-Strings."""
              out = val
              for _ in range(max_depth):
                  if isinstance(out, str):
                      s = out.strip()
                      try:
                          out = json.loads(s)
                          continue
                      except Exception:
                          return val
                  break
              return out

          def extract_codes(marketplaces):
              # akzeptiert: doppelt encodierte Strings, JSON-Listen/Dicts, CSV "DE,FR" oder Einzelcode "DE"
              m = marketplaces
              if isinstance(m, str):
                  m = multi_json_loads(m, max_depth=3)
              codes = []

              if isinstance(m, list):
                  for it in m:
                      if isinstance(it, str) and it.strip():
                          codes.append(it.strip().upper())
                      elif isinstance(it, dict):
                          c = it.get("code") or it.get("marketplace") or it.get("marketplace_code")
                          if c: codes.append(str(c).strip().upper())
                          else:
                              mid = str(it.get("id") or it.get("marketplaceId") or "").strip()
                              if mid in MAP_ID2CODE: codes.append(MAP_ID2CODE[mid])

              elif isinstance(m, dict):
                  for k in ("codes","list","marketplaces"):
                      v = m.get(k)
                      if isinstance(v, list):
                          for x in v:
                              if isinstance(x, str) and x.strip():
                                  codes.append(x.strip().upper())
                              elif isinstance(x, dict):
                                  c = x.get("code") or x.get("marketplace") or x.get("marketplace_code")
                                  if c: codes.append(str(c).strip().upper())
                                  else:
                                      mid = str(x.get("id") or x.get("marketplaceId") or "").strip()
                                      if mid in MAP_ID2CODE: codes.append(MAP_ID2CODE[mid])

              elif isinstance(m, str) and m.strip():
                  s = m.strip()
                  if "," in s:
                      codes += [c.strip().upper() for c in s.split(",") if c.strip()]
                  else:
                      codes.append(s.upper())

              return [c for c in codes if c]

          # --- schnelles Counting (Prefer: count=exact)
          def _count(url):
              hdr = {
                  "apikey": sb_key,
                  "Authorization": f"Bearer {sb_key}",
                  "Prefer": "count=exact",
                  "Range-Unit": "items",
                  "Range": "0-0"
              }
              try:
                  _, headers = _req(url, hdr)
                  cr = headers.get("content-range", "*/0")
                  return int(cr.split("/")[-1])
              except Exception:
                  return 0

          # Aktivität (letzte N Monate): Orders (mit MarketplaceId) oder Fees (mit Code)
          def has_activity(sb_url, tenant, code, months=12):
              if months is None or months <= 0:
                  return True
              # Näherung über Jahresgrenze: n*30 Tage rückwärts → Jahr extrahieren
              y0 = (date.today().replace(day=1) - timedelta(days=months*30)).year
              mid = CODE2ID.get(code)

              if mid:
                  uo = (f"{sb_url}/rest/v1/amazon_orders"
                        f"?tenant_id=eq.{tenant}&marketplace=eq.{mid}&period_year=gte.{y0}"
                        f"&select=amazon_order_id")
                  if _count(uo) > 0:
                      return True

              uf = (f"{sb_url}/rest/v1/amazon_fees"
                    f"?tenant_id=eq.{tenant}&marketplace=eq.{code}&period_year=gte.{y0}"
                    f"&select=amazon_order_id")
              return _count(uf) > 0

          EU = {"DE","FR","IT","ES","GB","NL","SE","PL","BE","TR","AE","SA","EG"}
          NA = {"US","CA","MX"}
          FE = {"JP","AU","SG"}
          def mp_region(code, fallback="eu"):
              if code in EU: return "eu"
              if code in NA: return "na"
              if code in FE: return "fe"
              return fallback

          force = set([c.strip().upper() for c in (os.getenv("OVERRIDE_CODES") or "").split(",") if c.strip()]) or None
          months = os.getenv("ACTIVITY_MONTHS")
          try:
              months = int(months) if months is not None and months != "" else 12
          except Exception:
              months = 12

          grace_days = os.getenv("NEW_CONN_GRACE_DAYS")
          try:
              grace_days = int(grace_days) if grace_days is not None and grace_days != "" else 45
          except Exception:
              grace_days = 45

          include = []
          skipped = []

          for row in rows or []:
              tenant = (row.get("tenant_id") or "").strip()
              if not tenant:
                  skipped.append({"tenant":"", "reason":"missing tenant_id"})
                  continue
              if filt_tenants != ["ALL"] and tenant not in filt_tenants:
                  skipped.append({"tenant":tenant, "reason":"filtered by inputs.tenants"})
                  continue

              refresh_token = (row.get("refresh_token") or "").strip()
              if not refresh_token:
                  skipped.append({"tenant":tenant, "reason":"missing refresh_token"})
                  continue

              seller_id = (row.get("seller_id") or "").strip()
              # Marketplaces extrahieren
              codes = extract_codes(row.get("marketplaces"))
              if not codes:
                  codes = ["DE"]  # sinnvolle Voreinstellung

              # optional hart begrenzen
              if force is not None:
                  codes = [c for c in codes if c in force]
                  if not codes:
                      skipped.append({"tenant":tenant, "reason":"no code after OVERRIDE_CODES"})
                      continue

              # Aktivität/Grace prüfen
              from datetime import date as ddate
              created_at = (row.get("created_at") or "")[:10]
              is_in_grace = False
              if created_at:
                  try:
                      cdate = ddate.fromisoformat(created_at)
                      is_in_grace = (ddate.today() - cdate).days <= grace_days
                  except Exception:
                      is_in_grace = False

              active_codes = []
              for c in sorted(set(codes)):
                  try:
                      if is_in_grace or has_activity(sb_url, tenant, c, months=months):
                          active_codes.append(c)
                  except Exception:
                      # Im Zweifel aufnehmen
                      active_codes.append(c)

              if not active_codes:
                  skipped.append({"tenant":tenant, "reason":"no recent activity (and out of grace)"})
                  continue

              # Region
              row_region = (row.get("region") or "").strip().lower()
              for code in active_codes:
                  region = row_region if row_region in {"eu","na","fe"} else mp_region(code)
                  include.append({
                      "tenant": tenant,
                      "marketplace": code,
                      "region": region,
                      "seller_id": seller_id
                  })

          total = len(include)
          if total == 0:
              print("# No matrix entries assembled. Details:")
              for s in skipped:
                  print(f" - skip: {s}")

          out = {"include": include}
          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              f.write(f"matrix={json.dumps(out)}\n")
              f.write(f"year={yy}\n")
              f.write(f"month={mm}\n")
              f.write(f"count={total}\n")

          print("# === prep-matrix summary ===")
          print("period:", yy, mm)
          print("include:", total)
          for it in include[:20]:
              print(" -", it)
          if total > 20:
              print(f" (+{total-20} more…)")

          PY

  etl:
    if: ${{ needs.prep-matrix.outputs.count != '0' }}
    name: ${{ matrix.tenant }} @ ${{ matrix.marketplace }} → ${{ needs.prep-matrix.outputs.year }}-${{ needs.prep-matrix.outputs.month }}
    needs: prep-matrix
    runs-on: ubuntu-latest
    timeout-minutes: 50
    concurrency:
      group: saas-${{ needs.prep-matrix.outputs.year }}-${{ needs.prep-matrix.outputs.month }}-${{ matrix.tenant }}-${{ matrix.marketplace }}
      cancel-in-progress: false
    strategy:
      max-parallel: ${{ fromJSON(inputs.max_parallel) }}
      matrix: ${{ fromJSON(needs.prep-matrix.outputs.matrix) }}

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with: { python-version: "3.11" }

      - name: Install deps
        run: |
          python -m pip install -U pip
          pip install -U python-amazon-sp-api supabase python-dotenv requests tzdata

      - name: Ensure jq
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi

      - name: Show matrix item
        run: |
          echo "TENANT=${{ matrix.tenant }}"
          echo "SELLER_ID=${{ matrix.seller_id }}"
          echo "MARKETPLACE=${{ matrix.marketplace }}"
          echo "REGION=${{ matrix.region }}"
          echo "PERIOD=${{ needs.prep-matrix.outputs.year }}-${{ needs.prep-matrix.outputs.month }}"

      - name: Show repo (top)
        run: |
          echo "PWD=$(pwd)"
          find . -maxdepth 4 -type f | sed -n '1,400p'

      - name: Autodetect scripts
        id: detect
        env:
          FEE_HINT:    ${{ vars.FEE_SCRIPT }}
          ORDERS_HINT: ${{ vars.ORDERS_SCRIPT }}
        run: |
          set -e
          python - <<'PY'
          import os, sys, pathlib
          root = pathlib.Path(".")
          def first_existing(hint, patterns, must_have=None):
              if hint:
                  p = root / hint
                  if p.exists():
                      return str(p)
              cands = []
              for pat in patterns:
                  cands += list(root.rglob(pat))
              if must_have:
                  filtered = []
                  for p in cands:
                      try:
                          txt = p.read_text(errors="ignore")
                      except Exception:
                          continue
                      if any(m in txt for m in must_have):
                          filtered.append(p)
                  if filtered:
                      cands = filtered
              if not cands:
                  return ""
              return str(sorted(cands, key=lambda p: len(str(p)))[0])

          fee = first_existing(
              os.getenv("FEE_HINT",""),
              ["AmzT_Fee.py", "**/*AmzT*Fee*.py", "**/*fee*.py"],
              must_have=["Finances(", "list_financial_event_groups"]
          )
          orders = first_existing(
              os.getenv("ORDERS_HINT",""),
              ["AmzT_Sales.py", "orders_month_supabase.py", "**/*AmzT*Sales*.py", "**/*orders*.py"],
              must_have=["Orders(", "get_orders"]
          )

          if not fee:
              print("::error::Could not find fee script. Set repo variable FEE_SCRIPT to relative path, e.g. libs/finance/AmzT_Fee.py")
              sys.exit(1)
          if not orders:
              print("::error::Could not find orders script. Set repo variable ORDERS_SCRIPT to relative path, e.g. libs/orders/AmzT_Sales.py or orders_month_supabase.py")
              sys.exit(1)

          print("FEE:", fee)
          print("ORDERS:", orders)
          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              f.write(f"fee_script={fee}\n")
              f.write(f"orders_script={orders}\n")
          PY

      - name: Fetch tenant refresh_token (region-aware)
        id: token
        env:
          SUPABASE_URL:  ${{ secrets.SUPABASE_URL }}
          SRK:           ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          TENANT_ID:     ${{ matrix.tenant }}
          REGION:        ${{ matrix.region }}
        run: |
          set -e
          python - << 'PY'
          import os, json, urllib.request, sys
          sb = os.environ["SUPABASE_URL"].rstrip("/")
          key = os.environ["SRK"]
          tid = os.environ["TENANT_ID"]
          reg = os.environ["REGION"]
          url = f"{sb}/rest/v1/amazon_connections?tenant_id=eq.{tid}&region=eq.{reg}&select=refresh_token"
          print("Fetch:", url)
          req = urllib.request.Request(url, headers={"apikey": key, "Authorization": f"Bearer {key}"})
          with urllib.request.urlopen(req, timeout=25) as r:
              data = json.loads(r.read().decode("utf-8"))
          if not data:
              url2 = f"{sb}/rest/v1/amazon_connections?tenant_id=eq.{tid}&select=refresh_token"
              print("Fallback:", url2)
              req2 = urllib.request.Request(url2, headers={"apikey": key, "Authorization": f"Bearer {key}"})
              with urllib.request.urlopen(req2, timeout=25) as r2:
                  data = json.loads(r2.read().decode("utf-8"))
          if not data or not data[0].get("refresh_token"):
              print(f"::error::No refresh_token for tenant={tid} (region={reg})")
              sys.exit(1)
          tok = data[0]["refresh_token"]
          print(f"::add-mask::{tok}")
          with open(os.environ["GITHUB_ENV"],"a") as f:
              f.write(f"SP_API_REFRESH_TOKEN={tok}\n")
          PY

      - name: Preflight env (fees)
        if: ${{ inputs.which == 'beides' || inputs.which == 'fees' }}
        env:
          LWA_CLIENT_ID:     ${{ secrets.LWA_CLIENT_ID }}
          LWA_CLIENT_SECRET: ${{ secrets.LWA_CLIENT_SECRET }}
          SUPABASE_URL:      ${{ secrets.SUPABASE_URL }}
          SRK:               ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
        run: |
          python - << 'PY'
          import os, sys
          need = ["SP_API_REFRESH_TOKEN","LWA_CLIENT_ID","LWA_CLIENT_SECRET","SUPABASE_URL","SRK"]
          miss = [k for k in need if not os.getenv(k)]
          print("Check FEES env…")
          for k in need:
            print(f" - {k}:", "OK" if os.getenv(k) else "MISSING")
          if miss: sys.exit(1)
          PY

      - name: Run Fees (last month)
        if: ${{ inputs.which == 'beides' || inputs.which == 'fees' }}
        env:
          LWA_APP_ID:        ${{ secrets.LWA_CLIENT_ID }}
          LWA_CLIENT_ID:     ${{ secrets.LWA_CLIENT_ID }}
          LWA_CLIENT_SECRET: ${{ secrets.LWA_CLIENT_SECRET }}
          SUPABASE_URL:              ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          SUPABASE_KEY:              ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          TENANT_ID:   ${{ matrix.tenant }}
          SELLER_ID:   ${{ matrix.seller_id }}
          MARKETPLACE: ${{ matrix.marketplace }}
          ORDERS_YEAR:  ${{ needs.prep-matrix.outputs.year }}
          ORDERS_MONTH: ${{ needs.prep-matrix.outputs.month }}
          LOCAL_TZ:    ${{ vars.LOCAL_TZ && vars.LOCAL_TZ || 'Europe/Istanbul' }}
          SPAPI_MAX_TOKEN_PAGES: ${{ vars.SPAPI_MAX_TOKEN_PAGES && vars.SPAPI_MAX_TOKEN_PAGES || '500' }}
        run: |
          python "${{ steps.detect.outputs.fee_script }}"

      - name: Preflight env (orders)
        if: ${{ inputs.which == 'beides' || inputs.which == 'orders' }}
        env:
          LWA_CLIENT_ID:     ${{ secrets.LWA_CLIENT_ID }}
          LWA_CLIENT_SECRET: ${{ secrets.LWA_CLIENT_SECRET }}
          SUPABASE_URL:      ${{ secrets.SUPABASE_URL }}
          SRK:               ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
        run: |
          python - << 'PY'
          import os, sys
          need = ["SP_API_REFRESH_TOKEN","LWA_CLIENT_ID","LWA_CLIENT_SECRET","SUPABASE_URL","SRK"]
          miss = [k for k in need if not os.getenv(k)]
          print("Check ORDERS env…")
          for k in need:
            print(f" - {k}:", "OK" if os.getenv(k) else "MISSING")
          if miss: sys.exit(1)
          PY

      - name: Run Orders (last month)
        if: ${{ inputs.which == 'beides' || inputs.which == 'orders' }}
        env:
          LWA_APP_ID:        ${{ secrets.LWA_CLIENT_ID }}
          LWA_CLIENT_ID:     ${{ secrets.LWA_CLIENT_ID }}
          LWA_CLIENT_SECRET: ${{ secrets.LWA_CLIENT_SECRET }}
          SUPABASE_URL:              ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          SUPABASE_KEY:              ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          TENANT_ID:   ${{ matrix.tenant }}
          SELLER_ID:   ${{ matrix.seller_id }}
          MARKETPLACE: ${{ matrix.marketplace }}
          ORDERS_YEAR:  ${{ needs.prep-matrix.outputs.year }}
          ORDERS_MONTH: ${{ needs.prep-matrix.outputs.month }}
          ORDERS_DATE_MODE: "created"
          LOCAL_TZ:    ${{ vars.LOCAL_TZ && vars.LOCAL_TZ || 'Europe/Istanbul' }}
        run: |
          python "${{ steps.detect.outputs.orders_script }}"

      # === Auto-Retry bei Fehlschlag (Orders + Fees) ===
      - name: Requeue on failure + log note into etl_runs
        if: failure()
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SRK: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          TENANT_ID: ${{ matrix.tenant }}
          MP: ${{ matrix.marketplace }}
          YY: ${{ needs.prep-matrix.outputs.year }}
          MM: ${{ needs.prep-matrix.outputs.month }}
          # Delay für den nächsten Versuch (Sekunden)
          RETRY_DELAY_SECONDS: "1800"
        run: |
          set -e

          # 1) Laufzeit für „geplanter Neuversuch“ berechnen (UTC-ISO)
          NEXT_TS="$(date -u -d "@$(( $(date +%s) + ${RETRY_DELAY_SECONDS} ))" +"%Y-%m-%dT%H:%M:%SZ")"
          NOTE="Auto-Retry (Orders+Fees) geplant um ${NEXT_TS} UTC (in ${RETRY_DELAY_SECONDS}s). Grund: Workflow-Failure."

          echo "==> Writing note into etl_runs…"
          curl -sS -X POST "${SUPABASE_URL%/}/rest/v1/etl_runs" \
            -H "apikey: ${SRK}" \
            -H "Authorization: Bearer ${SRK}" \
            -H "Content-Type: application/json" \
            -d "$(jq -n \
                  --arg t  "$TENANT_ID" \
                  --arg mp "$MP" \
                  --arg y  "$YY" \
                  --arg m  "$MM" \
                  --arg note "$NOTE" \
                  '{
                      tenant_id: $t,
                      marketplace: $mp,
                      period_year: ($y|tonumber),
                      period_month: ($m|tonumber),
                      status: "error",
                      run_log: $note
                    }')"

          echo "==> Fire repository_dispatch: etl-retry (beides)…"
          OWNER="${{ github.repository_owner }}"
          REPO="$(echo "${{ github.repository }}" | cut -d'/' -f2)"
          curl -sS -X POST \
            -H "Authorization: Bearer ${GH_PAT}" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${OWNER}/${REPO}/dispatches" \
            -d "$(jq -n \
                  --arg t   "$TENANT_ID" \
                  --arg y   "$YY" \
                  --arg m   "$MM" \
                  --argjson d ${RETRY_DELAY_SECONDS} \
                  '{event_type:"etl-retry", client_payload:{tenant:$t, year:($y|tonumber), month:($m|tonumber), which:"beides", delay_seconds:$d}}')"

          echo "Requeue (Orders+Fees) scheduled."
