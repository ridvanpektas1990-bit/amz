name: SaaS ETL (reusable)

on:
  workflow_call:
    inputs:
      period_year:   { type: string, required: false, description: "YYYY (leer = Vormonat)" }
      period_month:  { type: string, required: false, description: "M oder MM (leer = Vormonat)" }
      tenants:       { type: string, required: false, default: "ALL", description: "CSV (filter) oder ALL" }
      which:         { type: string, required: false, default: "beides", description: "fees|orders|beides" }
      max_parallel:  { type: number, required: false, default: 8 }
    secrets:
      SUPABASE_URL:              { required: true }
      SUPABASE_SERVICE_ROLE_KEY: { required: true }
      LWA_CLIENT_ID:             { required: true }
      LWA_CLIENT_SECRET:         { required: true }

jobs:
  prep-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.mk.outputs.matrix }}
      year:   ${{ steps.mk.outputs.year }}
      month:  ${{ steps.mk.outputs.month }}
    steps:
      - uses: actions/setup-python@v5
        with: { python-version: "3.11" }

      - id: mk
        env:
          IN_PERIOD_YEAR:  ${{ inputs.period_year }}
          IN_PERIOD_MONTH: ${{ inputs.period_month }}
          IN_TENANTS:      ${{ inputs.tenants }}
          SUPABASE_URL:    ${{ secrets.SUPABASE_URL }}
          SUPABASE_KEY:    ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
        run: |
          python - << 'PY'
          import os, json, urllib.request
          from datetime import date, timedelta

          def last_month():
              t = date.today()
              first = t.replace(day=1)
              prev = first - timedelta(days=1)
              return prev.year, prev.month

          yy = int(os.getenv("IN_PERIOD_YEAR") or 0) or last_month()[0]
          mm = int(os.getenv("IN_PERIOD_MONTH") or 0) or last_month()[1]

          filt_tenants = [x.strip() for x in (os.getenv("IN_TENANTS") or "ALL").split(",") if x.strip()]

          sb_url = os.getenv("SUPABASE_URL").rstrip("/")
          sb_key = os.getenv("SUPABASE_KEY")
          url = f"{sb_url}/rest/v1/amazon_connections?select=tenant_id,region,refresh_token,seller_id,marketplaces"
          req = urllib.request.Request(url, headers={"apikey": sb_key, "Authorization": f"Bearer {sb_key}"})
          with urllib.request.urlopen(req, timeout=30) as r:
              rows = json.loads(r.read().decode("utf-8"))

          # --- marketplaces -> Codes extrahieren (tolerant) -------------------
          MAP_ID2CODE = {
              "A1PA6795UKMFR9":"DE","A13V1IB3VIYZZH":"FR","APJ6JRA9NG5V4":"IT",
              "A1RKKUPIHCS9HS":"ES","A1F83G8C2ARO7P":"GB","A1805IZSGTT6HS":"NL",
              "A2NODRKZP88ZB9":"SE","A1C3SOZRARQ6R3":"PL","AMEN7PMS3EDWL":"BE",
              "A33AVAJ2PDY3EV":"TR","A39IBJ37TRP1C6":"AE","A2Q3Y263D00KWC":"SA",
              "A2VIGQ35RCS4UG":"EG"
          }

          def extract_codes(marketplaces):
              codes = []
              if marketplaces is None:
                  return codes
              if isinstance(marketplaces, list):
                  for it in marketplaces:
                      if isinstance(it, str):
                          codes.append(it)
                      elif isinstance(it, dict):
                          for k in ("code","marketplace","marketplace_code"):
                              if it.get(k):
                                  codes.append(str(it[k]))
                                  break
                          else:
                              mid = str(it.get("id") or it.get("marketplaceId") or "")
                              if mid in MAP_ID2CODE:
                                  codes.append(MAP_ID2CODE[mid])
              elif isinstance(marketplaces, dict):
                  for k in ("codes","list","marketplaces"):
                      v = marketplaces.get(k)
                      if isinstance(v, list):
                          for x in v:
                              if isinstance(x, str):
                                  codes.append(x)
                              elif isinstance(x, dict):
                                  for kk in ("code","marketplace","marketplace_code"):
                                      if x.get(kk):
                                          codes.append(str(x[kk]))
                                  mid = str(x.get("id") or x.get("marketplaceId") or "")
                                  if mid in MAP_ID2CODE:
                                      codes.append(MAP_ID2CODE[mid])
              return [str(c).strip().upper() for c in codes if str(c).strip()]
          # --------------------------------------------------------------------

          EU = {"DE","FR","IT","ES","GB","NL","SE","PL","BE","TR","AE","SA","EG"}
          NA = {"US","CA","MX"}
          FE = {"JP","AU","SG"}
          def mp_region(code):
              if code in EU: return "eu"
              if code in NA: return "na"
              if code in FE: return "fe"
              return "eu"

          include = []
          for row in rows:
              tenant = (row.get("tenant_id") or "").strip()
              if not tenant:
                  continue
              if filt_tenants != ["ALL"] and tenant not in filt_tenants:
                  continue
              seller_id = (row.get("seller_id") or "").strip()
              codes = extract_codes(row.get("marketplaces"))
              if not codes:
                  codes = ["DE"]  # Default wenn NULL
              for code in sorted(set(codes)):
                  include.append({
                      "tenant": tenant,
                      "marketplace": code,
                      "region": mp_region(code),
                      "seller_id": seller_id
                  })

          if not include:
              raise SystemExit("No matrix from amazon_connections")

          out = {"include": include}
          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              f.write(f"matrix={json.dumps(out)}\n")
              f.write(f"year={yy}\n")
              f.write(f"month={mm}\n")
          PY

  etl:
    name: ${{ matrix.tenant }} @ ${{ matrix.marketplace }} → ${{ needs.prep-matrix.outputs.year }}-${{ needs.prep-matrix.outputs.month }}
    needs: prep-matrix
    runs-on: ubuntu-latest
    timeout-minutes: 50
    concurrency:
      group: saas-${{ needs.prep-matrix.outputs.year }}-${{ needs.prep-matrix.outputs.month }}-${{ matrix.tenant }}-${{ matrix.marketplace }}
      cancel-in-progress: false
    strategy:
      max-parallel: ${{ inputs.max_parallel }}
      matrix: ${{ fromJSON(needs.prep-matrix.outputs.matrix) }}

    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with: { python-version: "3.11" }

      - name: Install deps
        run: |
          python -m pip install -U pip
          pip install -U python-amazon-sp-api supabase python-dotenv requests tzdata

      - name: Show repo (top)
        run: |
          echo "PWD=$(pwd)"
          find . -maxdepth 4 -type f | sed -n '1,400p'

      - name: Autodetect scripts
        id: detect
        env:
          FEE_HINT: ${{ vars.FEE_SCRIPT }}
          ORDERS_HINT: ${{ vars.ORDERS_SCRIPT }}
        run: |
          set -e
          python - <<'PY'
          import os, sys, pathlib
          root = pathlib.Path(".")

          def first_existing(hint, patterns, must_have=None):
              # 1) fester Hint
              if hint:
                  p = root / hint
                  if p.exists():
                      return str(p)
              # 2) Suche per Muster
              cands = []
              for pat in patterns:
                  cands += list(root.rglob(pat))
              # 3) optional: inhaltlicher Check
              if must_have:
                  filtered = []
                  for p in cands:
                      try:
                          txt = p.read_text(errors="ignore")
                      except Exception:
                          continue
                      if any(m in txt for m in must_have):
                          filtered.append(p)
                  if filtered:
                      cands = filtered
              # 4) beste Wahl (kürzester Pfad)
              if not cands:
                  return ""
              return str(sorted(cands, key=lambda p: len(str(p)))[0])

          fee = first_existing(
              os.getenv("FEE_HINT",""),
              ["AmzT_Fee.py", "**/*AmzT*Fee*.py", "**/*fee*.py"],
              must_have=["Finances(", "list_financial_event_groups"]
          )
          orders = first_existing(
              os.getenv("ORDERS_HINT",""),
              ["AmzT_Sales.py", "orders_month_supabase.py", "**/*AmzT*Sales*.py", "**/*orders*.py"],
              must_have=["Orders(", "get_orders"]
          )

          if not fee:
              sys.exit("Could not find fee script – set repo variable FEE_SCRIPT to relative path, e.g. libs/finance/AmzT_Fee.py")
          if not orders:
              sys.exit("Could not find orders script – set repo variable ORDERS_SCRIPT to relative path, e.g. libs/orders/AmzT_Sales.py")

          print("FEE:", fee)
          print("ORDERS:", orders)
          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              f.write(f"fee_script={fee}\n")
              f.write(f"orders_script={orders}\n")
          PY

      - name: Fetch tenant refresh_token (region-aware)
        id: token
        env:
          SUPABASE_URL:  ${{ secrets.SUPABASE_URL }}
          SRK:           ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          TENANT_ID:     ${{ matrix.tenant }}
          REGION:        ${{ matrix.region }}
        run: |
          set -e
          python - << 'PY'
          import os, json, urllib.request, sys
          sb = os.environ["SUPABASE_URL"].rstrip("/")
          key = os.environ["SRK"]
          tid = os.environ["TENANT_ID"]
          reg = os.environ["REGION"]
          url = f"{sb}/rest/v1/amazon_connections?tenant_id=eq.{tid}&region=eq.{reg}&select=refresh_token"
          req = urllib.request.Request(url, headers={"apikey": key, "Authorization": f"Bearer {key}"})
          with urllib.request.urlopen(req, timeout=25) as r:
              data = json.loads(r.read().decode("utf-8"))
          if not data:
              # Fallback: ohne Regionsfilter
              url2 = f"{sb}/rest/v1/amazon_connections?tenant_id=eq.{tid}&select=refresh_token"
              req2 = urllib.request.Request(url2, headers={"apikey": key, "Authorization": f"Bearer {key}"})
              with urllib.request.urlopen(req2, timeout=25) as r2:
                  data = json.loads(r2.read().decode("utf-8"))
          if not data or not data[0].get("refresh_token"):
              print(f"::error::No refresh_token for tenant={tid} (region={reg})")
              sys.exit(1)
          tok = data[0]["refresh_token"]
          print(f"::add-mask::{tok}")
          with open(os.environ["GITHUB_ENV"],"a") as f:
              f.write(f"SP_API_REFRESH_TOKEN={tok}\n")
          PY

      - name: Run Fees (last month)
        if: ${{ inputs.which == 'beides' || inputs.which == 'fees' }}
        env:
          # SP-API (App creds)
          LWA_APP_ID:        ${{ secrets.LWA_CLIENT_ID }}
          LWA_CLIENT_ID:     ${{ secrets.LWA_CLIENT_ID }}
          LWA_CLIENT_SECRET: ${{ secrets.LWA_CLIENT_SECRET }}
          # Supabase
          SUPABASE_URL:              ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          SUPABASE_KEY:              ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          # Kontext
          TENANT_ID:   ${{ matrix.tenant }}
          SELLER_ID:   ${{ matrix.seller_id }}
          MARKETPLACE: ${{ matrix.marketplace }}
          ORDERS_YEAR:  ${{ needs.prep-matrix.outputs.year }}
          ORDERS_MONTH: ${{ needs.prep-matrix.outputs.month }}
          LOCAL_TZ:    ${{ vars.LOCAL_TZ || 'Europe/Istanbul' }}
          SPAPI_MAX_TOKEN_PAGES: ${{ vars.SPAPI_MAX_TOKEN_PAGES || '500' }}
        run: |
          python "${{ steps.detect.outputs.fee_script }}"

      - name: Run Orders (last month)
        if: ${{ inputs.which == 'beides' || inputs.which == 'orders' }}
        env:
          LWA_APP_ID:        ${{ secrets.LWA_CLIENT_ID }}
          LWA_CLIENT_ID:     ${{ secrets.LWA_CLIENT_ID }}
          LWA_CLIENT_SECRET: ${{ secrets.LWA_CLIENT_SECRET }}
          SUPABASE_URL:              ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          SUPABASE_KEY:              ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          TENANT_ID:   ${{ matrix.tenant }}
          SELLER_ID:   ${{ matrix.seller_id }}
          MARKETPLACE: ${{ matrix.marketplace }}
          ORDERS_YEAR:  ${{ needs.prep-matrix.outputs.year }}
          ORDERS_MONTH: ${{ needs.prep-matrix.outputs.month }}
          ORDERS_DATE_MODE: "created"
          LOCAL_TZ:    ${{ vars.LOCAL_TZ || 'Europe/Istanbul' }}
        run: |
          python "${{ steps.detect.outputs.orders_script }}"
